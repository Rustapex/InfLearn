<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Array 배열</title>
  </head>
  <body>
    <script>
      /* 배열 : 순서가 있는 데이터 목록 */
      let arr = [];
      arr[0] = 10;
      console.log(arr); /* arr = [10] 출력 */
      arr[1] = 20; /*  index 2번쨰 arr[1] */
      console.log(arr); /* arr = [10, 20] 출력 */

      arr[5] = 50;
      console.log(arr);
      /* ? 중앙에 빈 요소들 어떤값 나오는지 index로 배열 안 item 넣는 것 위험 */
    </script>
    <script>
      let arr = ["a", "b"];
      console.log(arr.length + ": 배열의 크기");

      let arr2 = ["a"];
      arr.push(10); /* 배열에 요소 삽입 index 작 -> 큰 순으로 */
      console.log(arr); /* arr = [10, 'a'] */

      arr.pop(); /* 배열의 요소 삭제 index 큰 -> 작 순으로 */
      console.log(arr); /* arr = [10] , 'a' 삭제 */

      arr.push(30); /* arr = [10, 30] */
      arr.splice(0, 1); /* 0번 index 에서 하나 지움, 배열 값 실제로 변경 */
      console.log(arr); /* arr = [30] */
    </script>
    <script>
      /* 배열 반복문 */
      let arr3 = ["a", "b", "c"];
      arr3.forEach(function (value) {
        /* 익명함수, 함수명이 없는 함수 */
        console.log(value); /* value 값을 모두 출력할 때까지 반복 */
      }); /* a \n b\n, c\n 출력 */
    </script>
    <script>
      /* ===============================
     map, filter, forEach, slice 비교
     =============================== */

      let arr4 = [1, 2, 3];

      /* -------------------------------
     1) map: "변환"해서 새 배열 생성
     - 기존 arr4는 변경되지 않음
     - return 값이 새 배열(arr5)에 들어감
  -------------------------------- */
      let arr5 = arr4.map(function (item) {
        return item * 10;
      });
      console.log(arr5); // [10, 20, 30]
      console.log(arr4); // [1, 2, 3] (원본 유지)

      /* -------------------------------
     2) forEach로 map 대체:
     - forEach는 "반환"이 없어서
       새 배열을 직접 만들고(push) 채움
  -------------------------------- */
      let newArr4 = [];
      arr4.forEach(function (value) {
        newArr4.push(value * 10);
      });
      console.log(newArr4); // [10, 20, 30]

      /* -------------------------------
     3) filter: "조건에 맞는 것만" 골라 새 배열 생성
     - return true인 요소만 새 배열에 포함
     - ⚠️ filter 결과를 변수에 담아야 확인 가능
  -------------------------------- */
      let filteredArr = arr4.filter(function (item) {
        if (item == 2) {
          return true; // 조건을 만족하면 포함
        }
        // 조건 불만족이면 return 안 하거나 false 반환 → 제외됨
      });
      console.log(filteredArr); // [2]

      /* -------------------------------
     4) forEach로 filter 대체:
     - filter처럼 자동으로 새 배열을 만들어주지 않으므로
       직접 배열을 만들고 조건이면 push
  -------------------------------- */
      let result2 = [];
      arr4.forEach(function (value) {
        if (value == 2) {
          result2.push(value);
        }
      });
      console.log(result2); // [2]

      /* ======================================================
     ✅ 여기부터 추가: slice
     ====================================================== */

      /* -------------------------------
     5) slice: 배열의 "일부분을 복사해서" 새 배열 생성
     - 원본 arr4는 변경되지 않음
     - 형식: arr.slice(start, end)
       * start 포함, end 미포함
       // slice(start,end) => 이거는 시작 index =  start, 끝나는 index = end-1
  -------------------------------- */

      // 예시1) 인덱스 1부터 끝까지 복사 → [2, 3]
      let sliced1 = arr4.slice(1);
      console.log(sliced1); // [2, 3]

      // 예시2) 인덱스 0부터 2 전까지(0,1만) → [1, 2]
      let sliced2 = arr4.slice(0, 2);
      console.log(sliced2); // [1, 2]

      // 예시3) 전체 복사(얕은 복사) → [1, 2, 3]
      let copyArr4 = arr4.slice();
      console.log(copyArr4); // [1, 2, 3]
      console.log(arr4); // [1, 2, 3] (원본 유지)

      /* -------------------------------
     6) forEach로 slice "대체" (일부분 복사 흉내)
     - slice는 내부적으로 범위를 잘라 새 배열을 주지만,
       forEach는 범위를 직접 조건으로 걸어 push 해야 함
     - 아래 코드는 arr4.slice(1) 과 같은 결과를 만듦 → [2, 3]
  -------------------------------- */
      let slicedByForEach = [];
      arr4.forEach(function (value, index) {
        if (index >= 1) {
          // start=1 처럼 동작
          slicedByForEach.push(value);
        }
      });
      console.log(slicedByForEach); // [2, 3]

      /* -------------------------------
     (추가 예시) arr4.slice(0, 2) 를 forEach로 흉내 → [1, 2]
  -------------------------------- */
      let slicedRangeByForEach = [];
      arr4.forEach(function (value, index) {
        if (index >= 0 && index < 2) {
          // start 포함, end 미포함 규칙 그대로
          slicedRangeByForEach.push(value);
        }
      });
      console.log(slicedRangeByForEach); // [1, 2]

      /* =========================
   shift(): 배열의 "맨 앞 요소"를 제거하고, 제거한 값을 반환
   - 원본 배열이 변경됨(파괴적 메서드)
   ========================= */

      // 기본 예제
      let arr = [1, 2, 3];

      let removed = arr.shift(); // 맨 앞 1 제거 + 반환
      console.log(removed); // 1
      console.log(arr); // [2, 3]

      // 여러 번 shift
      let removed2 = arr.shift(); // 맨 앞 2 제거
      console.log(removed2); // 2
      console.log(arr); // [3]

      /* =========================
   forEach로 shift "비슷하게" 표현하기(대체 흉내)
   - forEach는 원본에서 '제거'를 직접 못함
   - 대신 "첫 요소를 제외한 새 배열 만들기"로 동작을 흉내냄
   - ✅ 결과적으로 shift 이후 배열 상태([2,3])와 동일한 새 배열을 얻음
   ========================= */

      let arr8 = [1, 2, 3];

      // shift가 반환하는 값(removed) 흉내: 첫 요소를 따로 저장
      let removedLikeShift = arr8[0];

      // shift 후 배열(arr8) 흉내: 첫 요소 제외하고 새 배열 구성
      let afterShiftLike = [];
      arr8.forEach(function (value, index) {
        if (index !== 0) afterShiftLike.push(value);
      });

      console.log(removedLikeShift); // 1
      console.log(afterShiftLike); // [2, 3]
      // console.log(arr8);          // [1, 2, 3]  (원본은 그대로! shift와 다른 점)
    </script>
  </body>
</html>
